The project to learn OO design concepts and MDI application development in Java

Требуется:
----------

1. Добавить пункт меню, позволяющий закрыть приложение
   и сделать так, чтобы в методе выдавался запрос на подтверждение выхода (класс JOptionPane)
2. Добавить обработку события выхода из приложения
3. Сделать так, чтобы диалог на основе JOptionPane выдавал текст на кнопках на русском языке.

Задачи на 2-й семестр по курсу ООП
==================================

Знакомство с устройством MDI приложения на Java
===============================================

В предоставленном комплекте исходников уже реализован некоторый функционал
MDI приложения (главное окно, меню, окно протокола, окно моделирования
движения робота).

Требуется разобраться со следующими моментами:

- как запускается приложение
- как создаются окна
- как инициализируется меню
- как подключаются обработчики событий

**Задания:**

- требуется добавить пункт меню, позволяющий закрыть приложение
- требуется собрать обработку события выхода из приложения в один метод
  и сделать так, чтобы в этом методе выдавался запрос на подтверждение
  выхода (см. класс JOptionPane)

**Дополнительное задание:**

- сделать так, чтобы диалог на основе JOptionPane выдавал текст на кнопках
  на русском языке.

Методические указания по задаче 1
=================================

Добавление пункта меню делается просто копированием уже имеющегося кода.
При изменении кода построения меню следует обратить внимание студента на
то, что в исходном состоянии код неудобен для работы.
А именно, уместно выделить код построения выпадающих меню в отдельные методы.

При добавлении нового пункта меню потребуется какой-то метод для обработки
события. Нужно будет добавить этот метод (в класс MainApplicationFrame).
Затем нужно сообразить, как закрыть приложение. Есть два подхода. В любом
случае стоит посмотреть точки использования константы JFrame.EXIT_ON_CLOSE
управляющей поведением JFrame при возникновении события закрытия окна
(WindowEvent.WINDOW_CLOSING). Соответственно, в обработчике события либо
можно повторить вызов System.exit(0) (это будет соответствовать
стандартной реакции на событие закрытия, но нарушает идеологию выполнения
действий через события; в частности, другие компоненты не узнают о том,
что программа завершается, поскольку не получат события
WindowEvent.WINDOW_CLOSING), либо (что в некотором смысле правильнее)
синтезировать посылку события WindowEvent.WINDOW_CLOSING, чтобы
сработал стандартный обработчик. В этих случаях пункт меню уже будет
работать.

Вот пример кода, который формирует событие на закрытие
приложения:

```java
JMenuItem exitItem=new JMenuItem("Выход",KeyEvent.VK_X|KeyEvent.VK_ALT);
        exitItem.addActionListener((event)->{
        Toolkit.getDefaultToolkit().getSystemEventQueue().postEvent(
        new WindowEvent(this,WindowEvent.WINDOW_CLOSING));
        });
```

Собственно, тут важно:

1. Разобраться, какое событие отвечает за закрытие
2. Сообразить, как добраться до очереди событий
3. Как сформировать правильное событие

Для того, чтобы среагировать на закрытие приложение следует перехватить
соответсвующее событие. Это делается путем регистрации слушателя
WindowListener (проще использовать заготовку в виде WindowAdapter) в
главном окне приложения (см. метод addWindowListener). Для перехвата
события закрытия нужен метод WindowListener.windowClosing.

Затем для выдачи стандартных диалогов подтверждения действия следует
использовать класс JOptionPane. В этом классе есть набор статических
методов, позволяющих отображать все стандартные диалоги подтверждения.
Наблюдение: по умолчанию этот класс будет выдавать текст на кнопках не на
русском языке. Правильная локализация - это отдельная задача для сильных
студентов.

Также потребуется сообразить, что нужно отключить действие при закрытии
приложения, настроенное по умолчанию. Делается это вызовом:
setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);

Знакомство с управлением разнородными объектами - 2
===================================================
Обычно считается хорошим тоном, когда приложение запоминает свое состояние
на момент выхода, чтобы можно было продолжить работу с ним без
дополнительной настройки при последующем запуске.

Задания:
=======

**Задания:**

- в методе выхода из приложения нужно сохранить (в файл) положения окошек
  (положение на экране, развернутое/свернутое состояние)
- при запуске приложения следует восстановить геометрию окошек приложения
  (положение на экране, развернутое/свернутое состояние)

Файл с конфигурацией следует создавать в домашнем каталоге пользователя.

Методические указания по задаче 2
=================================

Это задание направлено на отработку следующих навыков.

- наделение разных классов некоторым общим поведением (способность сохранять и восстанавливать состояние)
- введение абстракций данных (некоторая общая модель для сохранения состояния окна)

Прежде всего, нужно заметить, что в приложении два окна, реализованных как
независимые классы без общего предка. То есть просто так ввести общее
умение сохраняться негде (да, в принципе есть вариант введения общего
предка, но это очень неудобно и неправильно с точки зрения организации
приложения, поскольку приложение может содержать окна, не обязательно
наследуемые от JInternalFrame, то есть способность к сохранению не должна  
быть привязана именно к этому типу). Значит, требуется интерфейс с
методами "сохранить состояние" и "восстановить состояние".

Следующий вопрос: куда это самое состояние сохранять. Понятно, что эти
методы не должны работать напрямую с файлом, поскольку конкретный
компонент не имеет права знать о том, как глобально устроен механизм
сохранения настроек. Значит, нужна некоторая абстракция данных, в рамках
которой компонент сможет построить отчуждаемое представление состояния (по
сути, произвести маршаллинг данных своего состояния). Тут подходы могут
быть разными.
Мне наиболее простой кажется подход, когда состояние сохраняется в словарь (Map<String, String>).
Тогда каждая компонента составляет свой словарь. А затем отдельные словари можно собрать в один
общий путем приписывания префиксов к ключам отдельных словарей.

Например:
окно протокола формирует словарь:

```
width -> 100
height -> 200
```

и окно для моделирования движения робота формирует словарь:

```
width -> 300
height -> 400
```

Тогда мы собираем всю эту информацию в один общий словарь:

```
log.width -> 100
log.height -> 200
model.width -> 300
model.height -> 400
```

При таком подходе код достаточно удачно распадается на следующие
компоненты:

- код записи словаря в файл и чтения словаря из файла
- код формирования подсловаря по общему словарю (фильтрация по префиксу ключа) и код добавления подсловаря к словарю (
  приписывание префикса ключа)
- код формирования словарей отдельных компонент

Работу с подсловарями можно организовать как отдельный класс, который
строится по исходному словарю и префиксу ключей. То есть реализуем класс
на основе шаблона "Фильтр" (его студенты уже знают), за основу берем
классы AbstractMap и AbstractSet (просто смотрим, какие методы нужно доопределить или переопределить).

Код формирования словаря состояния отдельных компонент можно также собрать
в общий класс, к методам которого отдельные компоненты будут обращаться
для формирования своего состояния.

Важное замечание. Может возникнуть соблазн воспользоваться тем свойством,
что все графические компоненты в Java являются сериализуемыми. Но это
плохая идея (попытка использовать сериализацию завершится неуспехом, и это
правильно). Графические компоненты являются сериализуемыми лишь по
историческим причинам.

Именно поэтому правильное решение этой задачи основано на идее, похожей на
сериализацию (отдельный интерфейс для описания этого свойства), но с
отдельной реализацией, которую мы сами контролируем.


Методические указания по задаче 3
=================================

Идеи задач
==========

*В качестве следующей (3-й по счету) задачи планирую следующую (на обкатку идеи MVC):*

- реализовать новое окно (например, на основе диалоговых компонент), в котором будут отображаться текущие координаты
  робота
- для этого придется разделить логику отображения робота (визуализацию) и модель робота (код получения координат и
  моделирования движения)
- модель нужно будет описать как обозреваемый объект (Observable), чтобы затем окно могло подписаться на уведомления от
  модели и обновлять свое состояние
- с использованием этого нового окна и/или окна протоколирования нужно
  исправить ошибку в логике управления роботом (сейчас при определенном
  взаимном расположении робота и целевой точки робот уходит в
  противоположном направлении).

По сути эта задача предполагает использование того материала, который мы рассмотрели на лекциях.
Ну и продолжаем проявлять ситуации, в которых необходим рефакторинг.

Задача №4
=========

Придумать и реализовать структуру данных для хранения записей, отображаемых в окне протоколирования.
В исходной версии кода в качестве такой структуры использован ArrayList
без какой-либо самоочистки.
В реальности же обычно требуется, чтобы размер хранимой (и отображаемой в  
окне) части протокола был ограничен.
Но если просто удалять из ArrayList старые записи, это приведет к неэффективной
реализации (добавление записи будет работать за O(N),
поскольку придется удалять устаревшие записи из начала структуры)
и к проблемам с конкурентным доступом (возникает состояние гонки между добавлением данных и итерированием существующих).

**Соответственно, структура для хранения протокола должна обладать
следующими свойствами:**

- имела ограниченный размер (старые записи вытесняются)
- должна быть потокобезопасной (запись и чтение порождают состояние гонки)
- должна быть возможность доступа к части данных (сегмент смежных записей)
  по индексам начала и конца (такая операция, по идее, нужна для
  эффективного отображения данных в окне, чтобы не читать полный лог)

- добавление данных (с потенциальным удалением старых) и чтение уже
  хранящихся должны быть быстрыми (т.е. никаких O(n))
- должна возвращать потокобезопасный итератор (то есть добавление данных
  во время итерирования не должно разрушать итератор)

Первые 3 пункта могут быть реализованы на любой структуре (стэк, очередь,
массив), но потребуется сделать структуру потокобезопасной (конкурентные
чтение и запись).

Последние 2 пункта - усложненная версия задачи, позволяющая
познакомиться, например, с темпоральными структурами данных.

Задача №5
=========

Сделать так, чтобы приложение было локализовано (то есть обеспечить
возможность выбора языка, на котором работает пользовательский интерфейс).

Для упрощения задачи можно сделать следующие допущения:

- локализацию проводим только для собственных компонент программы
  (сообщения в готовых диалогах Swing переводить не нужно);
- считаем, что должны поддерживаться два языка: русский (выводится в
  обычном русском алфавите) и транслит (русский язык, выводимый латиницей).

Для решения задачи следует разобраться с работой классов ResourceBundle и
с тем, как формировать сообщения через форматирование.

**Усложнение задачи:**
Ускорить форматирование сообщений за счет использования кэша.
Здесь важно разобраться с тем, что Java предоставляет два механизма
для шаблонизации:
на основе класса MessageFormat, и на основе класса Formatter.

В случае с классом MessageFormat можно заметить, что вызов MessageFormat.format
сводится к запуску парсера (создает объект MessageFormat), который потом
используется для форматирования.
Так вот в кэше можно сохранять эти самые созданные объекты MessageFormat,
и тогда форматирование будет работать существенно быстрее
(парсер работает дольше, чем код форматирования).
В случае с классом Formatter такая техника, увы, не работает.


Задача №6
=========

Сделать так, чтобы можно было загружать "роботов" извне.
А именно, добавить возможность выбрать файл .jar,
в котором были бы собраны классы (файлы с байт-кодом),
содержащие логику работы робота (например, робот может быть 4-колесным)
и правила его визуализации.

Задача направлена на то, чтобы дать возможность поработать с загрузчиками
классов. При загрузке файла следует убедиться, что это именно jar-архив, а
затем создать URLClassLoader, чтобы загрузить необходимые классы.

Дополнительные идеи:
====================

И на базе моделирования движения робота возникает серия задач:

- бой роботов, когда один из них управляется по сети из другой программы
  (отрабатываем сетевое взаимодействие)

- роботы автономны, но программа позволяет загрузить логику работы робота
  из внешнего файла (class-файл с реализацией некоторого интерфейса) (тут
  отрабатываем использование загрузчиков классов и динамическое связывание)

- навигация роботов (объезд препятствий), причем можно вводить сложности из реальной жизни (скольжение, инерцию и т.п.),
  управление с задержкой (т.е. когда присутствует латентность между получением
  телеметрии от робота и исполнением сформированной команды)

- сетевое взаимодействие (несколько роботов на одном экране, могут, например, как-то взаимодействовать, стрелять или
  толкаться, и управление дополнительными роботами должно быть с удаленного клиента)

- кооперативная многозадачность (если есть несколько роботов, надо давать им возможность поработать, причем кванты
  времени должны по возможности быть честными, т.е. разные роботы должны получать
  равные по времени кванты; код должен быть устойчивым к падениям в коде конкретного робота)

- что-то своё (Необходимо согласовать!!!)
